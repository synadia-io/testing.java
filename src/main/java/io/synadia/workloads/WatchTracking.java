/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.synadia.workloads;

import io.nats.client.Connection;
import io.nats.client.KeyValue;
import io.nats.client.Nats;
import io.nats.client.Options;
import io.nats.client.api.KeyValueEntry;
import io.nats.client.api.KeyValueWatcher;
import io.nats.jsmulti.shared.ProfileStats;
import io.nats.jsmulti.shared.Stats;
import io.synadia.CommandLine;
import io.synadia.ParsedEntry;
import io.synadia.Workload;
import io.synadia.support.Debug;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.locks.ReentrantLock;

import static io.synadia.support.Reporting.*;

public class WatchTracking extends Workload {
    public enum Which {
        Stats("Stats"),
        Profile("Profile");
        final String workloadName;
        Which(String workloadName) {
            this.workloadName = workloadName;
        }
    }

    private final Which which;
    private final String bucket;

    public WatchTracking(Which which, CommandLine commandLine) {
        super(which.workloadName, commandLine);
        this.which = which;
        if (which == Which.Stats) {
            bucket = params.statsBucket;
        }
        else {
            bucket = params.profileBucket;
        }
    }

    @Override
    public void runWorkload() throws Exception {
        Options options = getAdminOptions();
        try (Connection nc = Nats.connect(options)) {
            KeyValue kv = nc.keyValue(bucket);
            WtWatcher watcher;
            if (which == Which.Stats) {
                watcher = new StatsWatcher();
            }
            else {
                watcher = new ProfileWatcher();
            }
            kv.watchAll(watcher);

            //noinspection InfiniteLoopStatement
            while (true) {
                //noinspection BusyWait
                Thread.sleep(params.watchWaitTime);
                watcher.report();
            }
        }
    }

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("HH:mm:ss");

    class StatsWatcher extends WtWatcher {
        Map<String, ParsedEntry> map;

        public StatsWatcher() {
            map = new HashMap<>();
        }

        @Override
        void subWatch(ParsedEntry p) {
            p.targetAndLabel(new Stats(p.jv), false);
            map.put(p.label, p);
        }

        @Override
        void subReport() {
            startNewReport();

            List<ParsedEntry> list = new ArrayList<>(map.values());
            ParsedEntry.sort(list);
            String date = FORMATTER.format(new Date());

            String lastMark = null;
            Stats totalStats = new Stats();
            for (ParsedEntry p : list) {
                boolean alreadyReported = p.reported;
                p.reported = true;
                Stats stats = (Stats)p.target;
                String mark = p.statType + p.contextId;
                if (!mark.equals(lastMark)){
                    if (lastMark != null) {
                        System.out.println(STATS_SEP_LINE);
                        statsLineReport("Total", totalStats);
                        System.out.println(STATS_FOOT_LINE);
                        totalStats = new Stats();
                    }
                    lastMark = mark;
                    System.out.println(STATS_TOP_LINE);
                    System.out.printf(STATS_LINE_HEADER, date);
                    System.out.println(STATS_SEP_LINE);
                }
                Stats.totalOne(stats, totalStats);
                statsLineReport(p.label + (alreadyReported ? "" : "*"), stats);
            }

            System.out.println(STATS_SEP_LINE);
            statsLineReport("Total", totalStats);
            System.out.println(STATS_FOOT_LINE);
        }
    }

    class ProfileWatcher extends WtWatcher {
        Map<String, ParsedEntry> map;

        public ProfileWatcher() {
            map = new HashMap<>();
        }

        @Override
        void subWatch(ParsedEntry p) {
            p.targetAndLabel(new ProfileStats(p.jv), true);
            map.put(p.label, p);
        }

        @Override
        void subReport() {
            startNewReport();
            System.out.println(PROFILE_TOP_LINE);
            System.out.printf(PROFILE_LINE_HEADER, FORMATTER.format(new Date()));
            System.out.println(PROFILE_SEP_LINE);

            List<ParsedEntry> list = new ArrayList<>(map.values());
            ParsedEntry.sort(list);
            String lastMark = null;
            for (ParsedEntry p : list) {
                ProfileStats ps = (ProfileStats) p.target;
                boolean alreadyReported = p.reported;
                p.reported = true;
                String mark = p.statType;
                if (lastMark == null) {
                    lastMark = mark;
                }
                else if (!lastMark.equals(mark)) {
                    lastMark = mark;
                    System.out.println(PROFILE_SEP_LINE);
                }
                profileLineReport(p.label + (alreadyReported ? "" : "*"), ps);
            }
            System.out.println(PROFILE_FOOT_LINE);
        }
    }

    abstract class WtWatcher implements KeyValueWatcher {
        private final ReentrantLock lock = new ReentrantLock();
        private boolean changed = false;
        private boolean waiting = false;
        abstract void subWatch(ParsedEntry parsedEntry);

        @Override
        public void watch(KeyValueEntry kve) {
            try {
                lock.lock();
                try {
                    changed = true;
                    subWatch(new ParsedEntry(kve));
                }
                finally {
                    lock.unlock();
                }
            }
            catch (Exception e) {
                Debug.info(label, e);
                Debug.stackTrace(label, e);
                System.exit(-1);
            }
        }

        @Override
        public void endOfData() {}

        abstract void subReport();

        void report() {
            lock.lock();
            try {
                if (changed) {
                    changed = false;
                    if (waiting) {
                        endWait();
                    }
                    subReport();
                }
                else {
                    waiting = true;
                    showWait();
                }
            }
            finally {
                lock.unlock();
            }
        }

        void startNewReport() {
            System.out.println("\n\n");
        }

        void showWait() {
            System.out.print(".");
        }

        void endWait() {
            System.out.println();
        }
    }
}
