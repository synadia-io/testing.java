/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.synadia.workloads;

import io.nats.client.*;
import io.nats.client.api.PublishAck;
import io.nats.client.api.StreamConfiguration;
import io.synadia.CommandLine;
import io.synadia.Debug;
import io.synadia.jnats.extension.AsyncJsPublisher;
import io.synadia.types.PublishType;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicLong;

public class Publisher extends Workload {

    static abstract class PublishRunnable implements Runnable {
        long start;
        long end;
        long elapsedNs;
        long elapsedMs;
        final JetStream js;
        final int id;
        final String subject;

        public PublishRunnable(JetStream js, int id, String publishSubjectPrefix) {
            this.js = js;
            this.id = id;
            this.subject = publishSubjectPrefix + id;
        }

        public void startRun() {
            start = System.nanoTime();
        }

        public void endRun() {
            end = System.nanoTime();
            elapsedNs = end - start;
            elapsedMs = elapsedNs / 1_000_000;
        }
    }

    public Publisher(CommandLine commandLine) {
        super(commandLine);
    }

    public void run() {
        List<PublishRunnable> prs = new ArrayList<>();
        try (Connection nc = Nats.connect(options)) {
            JetStreamManagement jsm = nc.jetStreamManagement();
            JetStream js = jsm.jetStream();
            handleStreamSetup(jsm);
            List<Thread> threads = new ArrayList<>();
            for (int x = 0; x < params.publishThreads; x++) {
                PublishRunnable pr = null;
                if (params.publishType == PublishType.Sync) {
                    pr = new SyncPublisher(js, x);
                }
                else if (params.publishType == PublishType.AsyncSawtooth) {
                    pr = new AsyncSawtoothPublisher(js, x);
                }
                if (pr != null) {
                    prs.add(pr);
                    Thread t = new Thread(pr);
                    t.start();
                    threads.add(t);
                }
            }
            for (Thread t : threads) {
                t.join();
            }
        }
        catch (Exception e) {
            Debug.info("Publisher", e);
            System.exit(-1);
        }

        Debug.PRINT_THREAD_ID = false;
        Debug.PRINT_TIME = false;

        for (PublishRunnable pr : prs) {
//                String ns = String.format("%,d", pr.elapsedNs) + " ns";
            String ms = String.format("%d", pr.elapsedMs) + "ms";
//                float avgns = (float) params.messageCount / pr.elapsedNs;
            float avgms = (float) params.messageCount / pr.elapsedMs;
            float avgsec = (float) params.messageCount / pr.elapsedMs / 1000;
            String ams = String.format("%.3f", avgms);
            String amsec = String.format("%.3f", avgsec);

            Debug.info(pr.getClass().getSimpleName(), ms, ams + " msg/s");
        }
    }

    private void handleStreamSetup(JetStreamManagement jsm) throws IOException, JetStreamApiException {
        if (params.createStream) {
            try {
                jsm.deleteStream(params.streamName);
            }
            catch (Exception ignore) {}
            jsm.addStream(StreamConfiguration.instance(params.streamConfigJson));
        }
    }

    AtomicLong pubCount = new AtomicLong(0);
    AtomicLong lastSeq = new AtomicLong(0);

    private void printMaybe(PublishAck pa) {
        long last = lastSeq.get();
        long next = pa.getSeqno();
        long pc = pubCount.incrementAndGet();
        if ((next - last) % params.reportIncrement == 0) {
            lastSeq.set(next);
            Debug.info("PUB", pc, next);
        }
    }

    static final byte[] DATA = new byte[1000];
    class SyncPublisher extends PublishRunnable {
        public SyncPublisher(JetStream js, int id) {
            super(js, id, params.publishSubjectPrefix);
        }

        @Override
        public void run() {
            startRun();
            for (int x = 1; x <= params.messageCount; x++) {
                try {
                    printMaybe(js.publish(subject, DATA));
                }
                catch (IOException | JetStreamApiException e) {
                    throw new RuntimeException(e);
                }
            }
            endRun();
        }
    }
    class AsyncSawtoothPublisher extends PublishRunnable {
        public AsyncSawtoothPublisher(JetStream js, int id) {
            super(js, id, params.publishSubjectPrefix);
        }

        @Override
        public void run() {
            List<CompletableFuture<PublishAck>> acks = new ArrayList<>();
            startRun();
            for (int x = 1; x <= params.messageCount; x++) {
                acks.add(js.publishAsync(subject, DATA));
                if (acks.size() == params.publishSawtoothBatch) {
                    checkAcks(acks);
                }
            }
            checkAcks(acks);
            endRun();
        }

        private void checkAcks(List<CompletableFuture<PublishAck>> acks) {
            while (!acks.isEmpty()) {
                try {
                    printMaybe(acks.removeFirst().get());
                }
                catch (ExecutionException e) {
                    throw new RuntimeException(e);
                }
                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private void publishAsyncx(JetStream js, int index) {
        String subject = params.publishSubjectPrefix + index;
        PublishListener publishListener = new PublishListener();

        AsyncJsPublisher.Builder builder =
            AsyncJsPublisher.builder(js)
                .maxInFlight(5000)
                .refillAllowedAt(4000)
                .pollTime(50)
                .holdPauseTime(200)
                .waitTimeout(2500)
                .publishListener(publishListener);

        try (AsyncJsPublisher publisher = builder.start()) {

            for (int x = 1; x <= params.messageCount; x++) {
                publisher.publishAsync(subject, DATA);
            }

            while (publisher.preFlightSize() > 0 || publisher.inFlightSize() > 0) {
                printStateThenWait(publisher, publishListener);
            }

            printState(publisher, publishListener);
        }
        catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void printStateThenWait(AsyncJsPublisher publisher, PublishListener publishListener) throws InterruptedException {
        printState(publisher, publishListener);
        Thread.sleep(params.printWait);
    }

    private void printState(AsyncJsPublisher publisher, PublishListener publishListener) {
        Debug.info("STATE",
            "elapsed=" + publishListener.elapsed(),
            "pre-flight=" + publisher.preFlightSize(),
            "in-flight=" + publisher.inFlightSize(),
            "published=" + publishListener.published,
            "acked=" + publishListener.acked,
            "exceptioned=" + publishListener.exceptioned,
            "timed out=" + publishListener.timedOut);
    }
}
