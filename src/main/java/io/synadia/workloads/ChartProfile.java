/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.synadia.workloads;

import io.nats.client.*;
import io.nats.client.api.MessageInfo;
import io.nats.client.support.JsonParser;
import io.nats.client.support.JsonValue;
import io.nats.client.support.JsonValueUtils;
import io.nats.jsmulti.shared.ProfileStats;
import io.synadia.CommandLine;
import io.synadia.Workload;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.ui.ApplicationFrame;
import org.jfree.chart.ui.RectangleInsets;
import org.jfree.chart.ui.UIUtils;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;

import javax.swing.*;
import java.io.IOException;
import java.util.Date;

import static io.synadia.utils.Constants.TIME_MS;

public class ChartProfile extends Workload {
    final String filter;
    public ChartProfile(CommandLine commandLine) {
        super("Chart Profile", commandLine);

        if (commandLine.args.size() != 1) {
            throw new RuntimeException("Filter Required");
        }
        filter = commandLine.args.getFirst();
    }

    Connection nc;
    TimeSeries al = new TimeSeries("Allocated");
    TimeSeries fm = new TimeSeries("Free Memory");

    @Override
    public void runWorkload() throws Exception {
        nc = Nats.connect(getAdminOptions());
        al = new TimeSeries("Allocated");
        fm = new TimeSeries("Free Memory");

        TimeSeriesCollection tscDataset = new TimeSeriesCollection();
        tscDataset.addSeries(al);
        tscDataset.addSeries(fm);
        loadData();

        JFreeChart chart = ChartFactory.createTimeSeriesChart(
            "Memory Usage", // title
            "Time",         // x-axis label
            "Memory (mb)",  // y-axis label
            tscDataset);
        chart.setBackgroundPaint(java.awt.Color.WHITE);

        XYPlot plot = (XYPlot) chart.getPlot();
        plot.setBackgroundPaint(java.awt.Color.LIGHT_GRAY);
        plot.setDomainGridlinePaint(java.awt.Color.WHITE);
        plot.setRangeGridlinePaint(java.awt.Color.WHITE);
        plot.setAxisOffset(new RectangleInsets(5.0, 5.0, 5.0, 5.0));
        plot.setDomainCrosshairVisible(true);
        plot.setRangeCrosshairVisible(true);
        plot.getRenderer().setSeriesPaint(0, java.awt.Color.RED);
        plot.getRenderer().setSeriesPaint(1, java.awt.Color.BLACK);

        XYItemRenderer r = plot.getRenderer();
        if (r instanceof XYLineAndShapeRenderer renderer) {
            renderer.setDefaultShapesVisible(true);
            renderer.setDefaultShapesFilled(true);
            renderer.setDrawSeriesLineAsPath(true);
        }

        DateAxis axis = (DateAxis) plot.getDomainAxis();
        axis.setVerticalTickLabels(true);
        // axis.setDateFormatOverride(new SimpleDateFormat("hh:mm:ss"));

        ChartPanel panel = new ChartPanel(chart, false);
        panel.setFillZoomRectangle(true);
        panel.setMouseWheelEnabled(true);

        ApplicationFrame af = new ApplicationFrame("Profile for " + filter);
        panel.setPreferredSize(new java.awt.Dimension(1500, 800));
        af.setContentPane(panel);
        af.pack();
        UIUtils.centerFrameOnScreen(af);
        af.setVisible(true);
        af.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        while (true) {
            Thread.sleep(params.watchWaitTime);
            loadData();
        }
    }

    private void loadData() throws InterruptedException, IOException, JetStreamApiException {
        JetStreamManagement jsm = nc.jetStreamManagement();

        MessageInfo mFirst = jsm.getFirstMessage(params.profileStreamName, params.profileStreamSubject);
        JsonValue jv = JsonParser.parse(mFirst.getData());
        long firstMs = JsonValueUtils.readLong(jv, TIME_MS, -1);

        MessageInfo mlast = jsm.getLastMessage(params.profileStreamName, params.profileStreamSubject);
        jv = JsonParser.parse(mlast.getData());
        long lastMs = JsonValueUtils.readLong(jv, TIME_MS, -1);

        long interval = (lastMs - firstMs) / 100;

        JetStream js = nc.jetStream();
        JetStreamSubscription sub = js.subscribe(
            params.profileStreamSubject,
            PushSubscribeOptions.builder().ordered(true)
                .build());

        long lastTime = 0;
        Message m = sub.nextMessage(10_000);
        while (true) {
            if (m != null) {
                String s = m.getSubject();
                if (s.contains(filter)) {
                    jv = JsonParser.parse(m.getData());
                    long timeMs = JsonValueUtils.readLong(jv, TIME_MS, -1);
                    long elapsed = timeMs - lastTime;
                    if (elapsed >= interval) {
                        lastTime = timeMs;
                        ProfileStats ps = new ProfileStats(jv);
                        Millisecond fixed = new Millisecond(new Date(timeMs));
                        al.addOrUpdate(fixed, mb(ps.allocatedMemory));
                        fm.addOrUpdate(fixed, mb(ps.freeMemory));
                    }
                }
                if (m.metaData().streamSequence() == mlast.getSeq()) {
                    break;
                }
            }
            m = sub.nextMessage(100);
        }
    }

    public double mb(long bytes) {
        return (double) bytes / 1024 / 1024;
    }
}
