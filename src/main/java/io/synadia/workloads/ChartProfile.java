/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.synadia.workloads;

import io.nats.client.*;
import io.nats.client.api.MessageInfo;
import io.nats.client.api.StreamInfo;
import io.nats.client.api.StreamInfoOptions;
import io.nats.client.support.JsonParser;
import io.nats.client.support.JsonValue;
import io.nats.client.support.JsonValueUtils;
import io.nats.jsmulti.shared.ProfileStats;
import io.synadia.CommandLine;
import io.synadia.Workload;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.ui.ApplicationFrame;
import org.jfree.chart.ui.RectangleInsets;
import org.jfree.chart.ui.UIUtils;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;

import javax.swing.*;
import java.awt.*;
import java.util.Date;

import static io.synadia.utils.Constants.TIME_MS;

public class ChartProfile extends Workload {
    final String filter;
    public ChartProfile(CommandLine commandLine) {
        super("Chart Profile", commandLine);

        if (commandLine.args.size() != 1) {
            throw new RuntimeException("Filter Required");
        }
        filter = commandLine.args.getFirst();
    }

    @Override
    public void runWorkload() throws Exception {
        TimeSeries al = new TimeSeries("Allocated");
        TimeSeries fm = new TimeSeries("Free Memory");
        TimeSeries hu = new TimeSeries("Heap Used");

        Options adminOpts = getAdminOptions();
        try (Connection nc = Nats.connect(adminOpts))
        {
            JetStreamManagement jsm = nc.jetStreamManagement();
            StreamInfo si = jsm.getStreamInfo(params.profileStreamName,
                StreamInfoOptions.builder().filterSubjects(params.profileStreamSubject).build());

            MessageInfo mFirst = jsm.getFirstMessage(params.profileStreamName, params.profileStreamSubject);
            JsonValue jv = JsonParser.parse(mFirst.getData());
            long firstMs = JsonValueUtils.readLong(jv, TIME_MS, -1);

            MessageInfo mlast = jsm.getLastMessage(params.profileStreamName, params.profileStreamSubject);
            jv = JsonParser.parse(mlast.getData());
            long lastMs = JsonValueUtils.readLong(jv, TIME_MS, -1);

            long interval = (lastMs - firstMs) / 100;

            JetStream js = nc.jetStream();
            JetStreamSubscription sub = js.subscribe(
                params.profileStreamSubject,
                PushSubscribeOptions.builder().ordered(true).build());
            Thread.sleep(1000); // so I don't have to wait for messages
            Message m = sub.nextMessage(1000);
            long lastTime = 0;
            while (m != null) {
                String s = m.getSubject();
                if (s.contains(filter)) {
                    jv = JsonParser.parse(m.getData());
                    long timeMs = JsonValueUtils.readLong(jv, TIME_MS, -1);
                    long elapsed = timeMs - lastTime;
                    if (elapsed >= interval) {
                        lastTime = timeMs;
                        ProfileStats ps = new ProfileStats(jv);
                        Millisecond fixed = new Millisecond(new Date(timeMs));
                        al.addOrUpdate(fixed, mb(ps.allocatedMemory));
                        fm.addOrUpdate(fixed, mb(ps.freeMemory));
                        hu.addOrUpdate(fixed, mb(ps.heapUsed));
                    }
                }
                m = sub.nextMessage(100);
            }
        }

        TimeSeriesCollection tscDataset = new TimeSeriesCollection();
        tscDataset.addSeries(al);
        tscDataset.addSeries(fm);
        tscDataset.addSeries(hu);

        JFreeChart chart = ChartFactory.createTimeSeriesChart(
            "Memory Allocation", // title
            "Time",              // x-axis label
            "Memory (mb)",       // y-axis label
            tscDataset);
        chart.setBackgroundPaint(Color.WHITE);

        XYPlot plot = (XYPlot) chart.getPlot();
        plot.setBackgroundPaint(Color.LIGHT_GRAY);
        plot.setDomainGridlinePaint(Color.WHITE);
        plot.setRangeGridlinePaint(Color.WHITE);
        plot.setAxisOffset(new RectangleInsets(5.0, 5.0, 5.0, 5.0));
        plot.setDomainCrosshairVisible(true);
        plot.setRangeCrosshairVisible(true);
        plot.getRenderer().setSeriesPaint(2, Color.BLACK);

        XYItemRenderer r = plot.getRenderer();
        if (r instanceof XYLineAndShapeRenderer renderer) {
            renderer.setDefaultShapesVisible(true);
            renderer.setDefaultShapesFilled(true);
            renderer.setDrawSeriesLineAsPath(true);
        }

        DateAxis axis = (DateAxis) plot.getDomainAxis();
        axis.setVerticalTickLabels(true);
        // axis.setDateFormatOverride(new SimpleDateFormat("hh:mm:ss"));

        ChartPanel panel = new ChartPanel(chart, false);
        panel.setFillZoomRectangle(true);
        panel.setMouseWheelEnabled(true);

        ApplicationFrame af = new ApplicationFrame("Profile for " + filter);
        panel.setPreferredSize(new java.awt.Dimension(1500, 800));
        af.setContentPane(panel);
        af.pack();
        UIUtils.centerFrameOnScreen(af);
        af.setVisible(true);
        af.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        Thread.sleep(1_000_000);
    }

    public double mb(long bytes) {
        return (double) bytes / 1024 / 1024;
    }
}
