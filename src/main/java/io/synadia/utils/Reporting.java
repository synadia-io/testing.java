/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.synadia.utils;

import io.nats.jsmulti.shared.ProfileStats;
import io.nats.jsmulti.shared.Stats;
import io.synadia.ParsedEntry;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;

public abstract class Reporting {

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("HH:mm:ss");

    public static final String STATS_TOP_LINE    = "┌─────────────────────┬───────────────────┬─────────────────┬──────────────────────────┬──────────────────┐";
    public static final String STATS_SEP_LINE    = "├─────────────────────┼───────────────────┼─────────────────┼──────────────────────────┼──────────────────┤";
    public static final String STATS_FOOT_LINE   = "└─────────────────────┴───────────────────┴─────────────────┴──────────────────────────┴──────────────────┘";
    public static final String STATS_LINE_HEADER = "│ %-19s │             count │            time │                 msgs/sec │        bytes/sec │\n";
    public static final String STATS_LINE_FORMAT = "│ %-19s │ %12s msgs │ %15s │ %15s msgs/sec │ %12s/sec │\n";

    public static void statsLineReport(String label, Stats stats) {
        long elapsed = stats.getElapsed();
        long messageCount = stats.getMessageCount();
        double messagesPerSecond = elapsed == 0 ? 0 : messageCount * Stats.MILLIS_PER_SECOND / elapsed;
        double bytesPerSecond = Stats.MILLIS_PER_SECOND * (stats.getBytes()) / (elapsed);
        System.out.printf(STATS_LINE_FORMAT, label,
            Stats.format(messageCount),
            Stats.humanTime(elapsed),
            Stats.format3(messagesPerSecond),
            Stats.humanBytes(bytesPerSecond));
    }

    public static final String PROFILE_TOP_LINE    = "┌─────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬─────────┬─────────┐";
    public static final String PROFILE_SEP_LINE    = "├─────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼─────────┼─────────┤";
    public static final String PROFILE_FOOT_LINE   = "└─────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴─────────┴─────────┘";
    public static final String PROFILE_LINE_HEADER = "│ %-19s │        max │   heap max │  allocated │       free │  heap used │  heap cmtd │   non used │   non cmtd │   alive │    dead │\n";
    public static final String PROFILE_LINE_FORMAT = "│ %-19s │ %10s │ %10s │ %10s │ %10s │ %10s │ %10s │ %10s │ %10s │ %7s │ %7s │\n";

    public static void profileLineReport(String label, ProfileStats p) {
        System.out.printf(PROFILE_LINE_FORMAT, label,
            Stats.humanBytes(p.maxMemory),
            Stats.humanBytes(p.heapMax),
            Stats.humanBytes(p.allocatedMemory),
            Stats.humanBytes(p.freeMemory),
            Stats.humanBytes(p.heapUsed),
            Stats.humanBytes(p.heapCommitted),
            Stats.humanBytes(p.nonHeapUsed),
            Stats.humanBytes(p.nonHeapCommitted),
            p.liveThreads.size() + "/" + p.threadCount,
            p.deadThreads.size() + "/" + p.threadCount);
    }

    public static void startNewReport() {
        System.out.println("\n\n");
    }

    public static void showWait() {
        System.out.print(".");
    }

    public static void endWait() {
        System.out.println();
    }

    public static boolean printStats(Collection<ParsedEntry> collection) {
        boolean anyNewData = false;
        List<ParsedEntry> list = new ArrayList<>(collection);
        ParsedEntry.sort(list);

        String date = FORMATTER.format(new Date());
        startNewReport();

        String lastMark = null;
        Stats totalStats = new Stats();
        for (ParsedEntry p : list) {
            boolean alreadyReported = p.reported;
            anyNewData = anyNewData || !alreadyReported;
            p.reported = true;
            Stats stats = (Stats)p.target;
            String mark = p.statType + p.contextId;
            if (!mark.equals(lastMark)){
                if (lastMark != null) {
                    System.out.println(STATS_SEP_LINE);
                    statsLineReport("Total", totalStats);
                    System.out.println(STATS_FOOT_LINE);
                    totalStats = new Stats();
                }
                lastMark = mark;
                System.out.println(STATS_TOP_LINE);
                System.out.printf(STATS_LINE_HEADER, date);
                System.out.println(STATS_SEP_LINE);
            }
            Stats.totalOne(stats, totalStats);
            statsLineReport(p.label + (alreadyReported ? "" : "*"), stats);
        }

        System.out.println(STATS_SEP_LINE);
        statsLineReport("Total", totalStats);
        System.out.println(STATS_FOOT_LINE);

        return anyNewData;
    }

    public static boolean printProfileStats(Collection<ParsedEntry> collection) {
        boolean anyNewData = false;
        List<ParsedEntry> list = new ArrayList<>(collection);
        ParsedEntry.sort(list);

        startNewReport();
        System.out.println(PROFILE_TOP_LINE);
        System.out.printf(PROFILE_LINE_HEADER, FORMATTER.format(new Date()));
        System.out.println(PROFILE_SEP_LINE);
        String lastMark = null;
        for (ParsedEntry p : list) {
            ProfileStats ps = (ProfileStats) p.target;
            boolean alreadyReported = p.reported;
            anyNewData = anyNewData || !alreadyReported;
            p.reported = true;
            String mark = p.statType;
            if (lastMark == null) {
                lastMark = mark;
            }
            else if (!lastMark.equals(mark)) {
                lastMark = mark;
                System.out.println(PROFILE_SEP_LINE);
            }
            profileLineReport(p.label + (alreadyReported ? "" : "*"), ps);
        }
        System.out.println(PROFILE_FOOT_LINE);
        return anyNewData;
    }
}
